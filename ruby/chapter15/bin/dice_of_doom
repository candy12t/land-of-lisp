#! /usr/bin/env ruby

$LOAD_PATH.unshift(File.expand_path('../lib', __dir__))
require 'dice_of_doom'

NUM_PLAYERS = 2
MAX_DICE = 3
BOARD_SIZE = 2
BOARD_HEXNUM = BOARD_SIZE * BOARD_SIZE

def gen_board
  Array.new(BOARD_HEXNUM) { [rand(NUM_PLAYERS), rand(MAX_DICE) + 1] }
end

def player_letter(n)
  if n < 0 or 24 < n
    raise StandardError.new('Error')
  end
  return (n + 97).chr
end

# TODO: refactor
def draw_board(board)
  # str = ''
  (0...BOARD_SIZE).each do |y|
    # (BOARD_SIZE - y).times { str += "  " }
    (BOARD_SIZE - y).times { print "  " }

    (0...BOARD_SIZE).each do |x|
      hex = board[x + BOARD_SIZE * y]
      # str += "#{player_letter(hex[0])}-#{hex[1]} "
      print "#{player_letter(hex[0])}-#{hex[1]} "
    end
    # str += "\n"
    print "\n"
  end

  # return str
end

def game_tree(board, player, spare_dice, first_move)
  return [player, board, add_passing_move(board, player, spare_dice, first_move, attacking_moves(board, player, spare_dice))]
end

def add_passing_move(board, player, spare_dice, first_move, moves)
  if first_move
    moves
  else
    moves.unshift([nil, game_tree(add_new_dice(board, player, spare_dice - 1), (player + 1) % NUM_PLAYERS, 0, true)])
  end
end

# board -> [[Palyer, DiceCount]]
# example [[0, 3], [1, 2], [1, 3], [0, 1]]
def attacking_moves(board, cur_player, spare_dice)
  player = ->(pos) { board[pos][0] }
  dice = ->(pos) { board[pos][1] }

  src_moves = (0...BOARD_HEXNUM).select { |src| player[src] == cur_player }

  src_moves.flat_map do |src|
    neighbors(src).flat_map do |dst|
      if !player[dst].nil? && player[dst] != cur_player && dice[src] > dice[dst]
        [[
          [src, dst],
          game_tree(
            board_attack(board, cur_player, src, dst, dice[src]),
            cur_player,
            spare_dice + dice[dst],
            nil
          )
        ]]
      else
        []
      end
    end
  end
end

def neighbors(pos)
  up = pos - BOARD_SIZE
  down = pos + BOARD_SIZE

  result = [up, down]

  unless pos % BOARD_SIZE == 0
    result << up - 1
    result << pos - 1
  end

  unless (pos + 1) % BOARD_SIZE == 0
    result << pos + 1
    result << down + 1
  end

  result.select { |p| p >= 0 && p < BOARD_HEXNUM }
end

def board_attack(board, player, src, dst, dice)
  board.each_with_index.map do |hex, pos|
    case pos
    when src
      [player, 1]
    when dst
      [player, dice - 1]
    else
      hex
    end
  end
end

def add_new_dice(board, player, spare_dice)
  f = ->(lst, n) {
    case
    when lst.nil?
      nil
    when n.zero?
      lst
    else
      cur_player, cur_dice = lst.first
      if cur_player == player && cur_dice < MAX_DICE
        [[cur_player, cur_dice + 1]].concat(f.call(lst.drop(1), n - 1))
      else
        [lst.first].concat(f.call(lst.drop(1), n))
      end
    end
  }

  return f.call(board.map(&:dup), spare_dice)
end

def play_vs_human(tree)
  print_info(tree)
  if tree[2]
    play_vs_human(handle_human(tree))
  else
    announce_winner(tree[1])
  end
end

def print_info(tree)
  puts
  puts "current player = #{player_letter(tree[0])}"
  draw_board(tree[1])
end

def handle_human(tree)
  puts
  print "choose your move: "
  moves = tree[2]

  moves.each_with_index do |move, index|
    action = move[0]
    puts
    print "#{index + 1}. "
    if action
      puts "#{action[0]} -> #{action[1]}"
    else
      print "end turn"
    end
  end

  puts
  moves[gets.chomp.to_i - 1][1]
end

def winners(board)
  tally = board.flatten.map(&:first)
  totals = tally.uniq.map { |player| [player, tally.count(player)] }
  best = totals.map(&:last).max
  totals.select { |x| x.last == best }.map(&:first)
end

def announce_winner(board)
  puts
  winners = winners(board)
  if winners.length > 1
    puts "The game is a tie between #{winners.map { |w| player_letter(w) }.join(", ")}"
  else
    puts "The winner is #{player_letter(winners.first)}"
  end
end

# play_vs_human(game_tree(gen_board, 0, 0, true))
p game_tree([[0, 1], [1, 1], [0, 2], [1, 1]], 0, 0, true)
# p board_attack([[0, 3], [0, 3], [1, 3], [1, 1]], 0, 1, 3, 3)
# p add_new_dice([[0, 1], [1, 3], [0, 2], [1, 1]], 0, 2)
