#! /usr/bin/env ruby

$LOAD_PATH.unshift(File.expand_path('../lib', __dir__))
require 'dice_of_doom'

NUM_PLAYERS = 2
MAX_DICE = 3
BOARD_SIZE = 2
BOARD_HEXNUM = BOARD_SIZE * BOARD_SIZE

def gen_board
  Array.new(BOARD_HEXNUM) { [rand(NUM_PLAYERS), rand(MAX_DICE) + 1] }
end

def player_letter(n)
  return (n + 65).chr
end

def draw_board(board)
  result = ""
  board.each_slice(BOARD_SIZE).with_index do |row, idx|
    result += "  " * (BOARD_SIZE - idx)
    row.each do |hex|
      result += "#{player_letter(hex[0])}-#{hex[1]} "
    end
    result += "\n"
  end
  return result
end

def game_tree(board, player, spare_dice, first_move)
  moves = attacking_moves(board, player, spare_dice)
  moves.unshift([nil, next_turn_tree(board, player, spare_dice)]) unless first_move
  return [player, board, moves]
end

def next_turn_tree(board, player, spare_dice)
  board = add_new_dice(board, player, spare_dice - 1)
  player = (player + 1) % NUM_PLAYERS
  return game_tree(board, player, 0, true)
end

def attacking_moves(board, cur_player, spare_dice)
  player = ->(pos) { board[pos][0] }
  dice = ->(pos) { board[pos][1] }

  (0...BOARD_HEXNUM)
    .select { |src| player[src] == cur_player}
    .flat_map { |src| attacking_moves_from_src(board, src, cur_player, spare_dice, player, dice) }
end

def attacking_moves_from_src(board, src, cur_player, spare_dice, player, dice)
  can_attack = ->(dst) { player[dst] && player[dst] != cur_player && dice[src] > dice[dst] }
  neighbors(src)
    .select { |dst| can_attack.call(dst) }
    .map { |dst| [[src, dst], game_tree(board_attack(board, cur_player, src, dst, dice[src]), cur_player, spare_dice + dice[dst], false)]}
end

def neighbors(pos)
  up = pos - BOARD_SIZE
  down = pos + BOARD_SIZE

  positions = [up, down]
  positions.push(up - 1, pos - 1) unless pos % BOARD_SIZE == 0
  positions.push(down + 1, pos + 1) unless (pos + 1) % BOARD_SIZE == 0
  positions.select { |p| p >= 0 && p < BOARD_HEXNUM }
end

def board_attack(board, player, src, dst, dice)
  board.each_with_index.map do |hex, pos|
    case pos
    when src then [player, 1]
    when dst then [player, dice - 1]
    else hex
    end
  end
end

def add_new_dice(board, player, spare_dice)
  f = ->(lst, n) {
    case
    when lst.nil?
      nil
    when n.zero?
      lst
    else
      cur_player, cur_dice = lst.first
      if cur_player == player && cur_dice < MAX_DICE
        [[cur_player, cur_dice + 1]].concat(f.call(lst.drop(1), n - 1))
      else
        [lst.first].concat(f.call(lst.drop(1), n))
      end
    end
  }

  return f.call(board.map(&:dup), spare_dice)
end

def play_vs_human(tree)
  print_info(tree)
  if tree[2] && !tree[2].empty?
    play_vs_human(handle_human(tree))
  else
    announce_winner(tree[1])
  end
end

def print_info(tree)
  puts
  puts "current player = #{player_letter(tree[0])}"
  puts draw_board(tree[1])
end

def handle_human(tree)
  puts
  print "choose your move: "
  moves = tree[2]

  moves.each_with_index do |move, index|
    action = move[0]
    puts
    print "#{index + 1}. "
    if action
      puts "#{action[0]} -> #{action[1]}"
    else
      print "end turn"
    end
  end

  puts
  moves[gets.chomp.to_i - 1][1]
end

def winners(board)
  tally = board.map(&:first)
  totals = tally.uniq.map { |player| [player, tally.count(player)] }
  best = totals.map(&:last).max
  totals.select { |x| x.last == best }.map(&:first)
end

def announce_winner(board)
  puts
  winners = winners(board)
  if winners.length > 1
    puts "The game is a tie between #{winners.map { |w| player_letter(w) }.join(", ")}"
  else
    puts "The winner is #{player_letter(winners.first)}"
  end
end

# board = gen_board
# tree = game_tree(board, 0, 0, true)
# play_vs_human(tree)
